var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Plotting","page":"API Reference","title":"Plotting","text":"","category":"section"},{"location":"api/#SLOPE.SLOPE","page":"API Reference","title":"SLOPE.SLOPE","text":"module SLOPE\n\nSorted L-One Penalized Estimation\n\n\n\n\n\n","category":"module"},{"location":"api/#SLOPE.slope","page":"API Reference","title":"SLOPE.slope","text":"slope(x, y; kwargs...) -> NamedTuple\n\nFit a SLOPE (Sorted L1 Penalized Estimation) model to the provided data.\n\nSLOPE is a regularization method that combines the L1 norm with a sorted penalty, encouraging both sparsity and grouping of features.\n\nArguments\n\nx: Matrix of predictors (dense or sparse)\ny: Response variable (vector)\n\nKeyword Arguments\n\nα::Union{AbstractVector,Real,Nothing}=nothing: Alpha sequence for regularization path\nλ::Union{AbstractVector,Symbol,Nothing}=:bh: Lambda sequence for regularization path. Can be a vector or a symbol indicating the type of sequence to generate. If nothing, the value :bh is used.\nfit_intercept::Bool=true: Whether to fit an intercept term\nloss::Symbol=:quadratic: Type of loss function\ncentering::Symbol=:mean: Method for centering predictors\nscaling::Symbol=:sd: Method for scaling predictors\npath_length::Int=100: Number of regularization path points\ntol::Float64=1e-5: Convergence tolerance for optimization\nmax_it::Int=10000: Maximum number of iterations\nq::Float64=0.1: Parameter controlling the shape of the penalty weights sequence. Should be in the range (0, 1). \nmax_clusters::Union{Int,Nothing}=nothing: Early path stopping criteria for maximum number of clusters (defaults to n+1) \ndev_change_tol::Float64=1e-5: Early path stopping criteria for tolerance for change in deviance \ndev_ratio_tol::Float64=0.999: Early path stopping criteria for tolerance for ratio of deviance\nα_min_ratio::Union{Float64,Nothing}=nothing: Fraction of maximum α to use as minimum value in the regularization path. Defaults to 1e-2 if n > p * m, otherwise 1e-4.\n\nReturns\n\nA SlopeFit object.\n\n\n\n\n\n","category":"function"},{"location":"api/#SLOPE.SlopeFit","page":"API Reference","title":"SLOPE.SlopeFit","text":"SlopeFit\n\nA structure containing the results of fitting a SLOPE model.\n\nFields\n\nintercepts::Vector{Vector{Float64}}: A vector of intercept vectors along the regularization path. For each point in the path, contains a vector of length m with class-specific intercepts.\ncoefficients::Vector{SparseMatrixCSC{Float64,Int}}: A vector of sparse coefficient matrices  along the regularization path. Each matrix is of size p×m where p is the number of  predictors and m is the number of response classes (1 for regression).\nα::Vector{Float64}: The alpha values used at each point of the regularization path.\nλ::Vector{Float64}: The lambda values used at each point of the regularization path.\nm::Int: The number of response classes (1 for regression, >1 for multinomial).\nloss::Symbol: The loss function used in the model fitting process.\nclasses::Union{Vector,Nothing}: A vector of unique class labels for the response variable. This is nothing for regression models (continuous responses).\n\n\n\n\n\n","category":"type"},{"location":"api/#SLOPE.slopecv","page":"API Reference","title":"SLOPE.slopecv","text":"slopecv(\n  x,\n  y;\n  α=nothing,\n  λ=:bh,\n  γ=[0.0],\n  q=[0.1],\n  n_folds=10,\n  n_repeats=1,\n  metric=:mse,\n  kwargs...\n)\n\nPerform cross-validation for SLOPE to find optimal hyperparameters.\n\nArguments\n\nx::Union{AbstractMatrix,SparseMatrixCSC}: Input feature matrix, can be dense or sparse.\ny::AbstractVector: Response vector.\n\nKeyword Arguments\n\nα::Union{AbstractVector,Real,Nothing}=nothing: SLOPE regularization path. If nothing, it's automatically generated.\nλ::Union{AbstractVector,Symbol,Nothing}=:bh: Sequence of regularization parameters. If nothing, it uses the default BH sequence (:bh).\nγ::Union{AbstractVector,Real}=[0.0]: Parameter controlling the regularization sequence. Multiple values create a grid search.\nq::Union{AbstractVector}=[0.1]: FDR parameter for BH sequence. Multiple values create a grid search.\nn_folds::Int=10: Number of cross-validation folds.\nn_repeats::Int=1: Number of times to repeat the CV process with different fold assignments.\nmetric::Symbol=:mse: Evaluation metric for cross-validation. Options include :mse, :mae, :accuracy, etc.\nkwargs...: Additional parameters passed to the SLOPE solver.\n\nReturns\n\nA SlopeCvResult object.\n\nExamples\n\n# Basic usage with default parameters\nresult = slopecv(X, y)\n\n# Cross-validation with custom parameters\nresult = slopecv(X, y, γ=[0.0, 0.1, 0.5], q=[0.1, 0.05], n_folds=5, metric=:accuracy)\n\n# Access best parameters and score\nbest_q = result.best_params[\"q\"]\nbest_γ = result.best_params[\"γ\"]\nbest_score = result.best_score\n\nSee Also\n\nslope: For fitting a SLOPE model with fixed parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#SLOPE.SlopeGridResult","page":"API Reference","title":"SLOPE.SlopeGridResult","text":"SlopeGridResult\n\nResults for a specific hyperparameter combination in the SLOPE cross-validation grid search.\n\nFields\n\nparams::Dict{String,Any}: Dictionary of hyperparameter values (e.g., \"q\", \"γ\")\nscores::Matrix{Real}: Cross-validation scores for each fold and alpha value\nalphas::Vector{Real}: Sequence of alpha values for the regularization path\nscores_means::Vector{Real}: Mean score across folds for each alpha\nscores_errors::Vector{Real}: Standard errors of scores across folds\n\n\n\n\n\n","category":"type"},{"location":"api/#SLOPE.SlopeCvResult","page":"API Reference","title":"SLOPE.SlopeCvResult","text":"SlopeCvResult\n\nResult structure from SLOPE cross-validation.\n\nFields\n\nmetric::Symbol: The evaluation metric used (e.g., :mse, :accuracy)\nbest_score::Real: The best score achieved during cross-validation\nbest_ind::Int: Index of the best parameter combination\nbest_α_ind::Int: Index of the best alpha value in the regularization path\nbest_params::Dict{String,Any}: Dictionary with the best parameter values\nresults::Vector{SlopeGridResult}: Grid search results, of type SlopeGridResult for each parameter combination\n\n\n\n\n\n","category":"type"},{"location":"api/#SLOPE.regweights","page":"API Reference","title":"SLOPE.regweights","text":"regweights(\n  p::Int;\n  q::Float64=0.1,\n  type::Symbol=:bh,\n  n=nothing,\n  θ1::Real=1.0,\n  θ2::Real=1.0\n)\n\nGenerates a sequence of regularization weights for the sorted L1 norm.\n\nArguments\n\np::Int: The number of lambda values to generate (number of features)\n\nKeyword Arguments\n\nq::Float64=0.1: The false discovery rate (FDR) level or quantile value (must be in (0, 1))\ntype::Symbol=:bh: The type of sequence to generate:\n:bh: Benjamini-Hochberg sequence\n:gaussian: Gaussian sequence\n:oscar: Octagonal Shrinkage and Clustering Algorithm for Regression\n:lasso: Lasso (all weights equal to 1.0)\nn::Union{Int, Nothing}=nothing: Number of observations (required for :gaussian type)\nθ1::Real=1.0: First parameter for OSCAR weights\nθ2::Real=1.0: Second parameter for OSCAR weights\n\nReturns\n\nVector{Float64}: The generated lambda sequence in decreasing order\n\nExamples\n\nλ = regweights(100)  # Benjamini-Hochberg with default q=0.1\nλ = regweights(100, q=0.05, type=:gaussian, n=200)\nλ = regweights(50, type=:oscar, θ1=1.5, θ2=0.5)\n\n\n\n\n\n","category":"function"},{"location":"api/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, SlopeCvResult}","page":"API Reference","title":"RecipesBase.apply_recipe","text":"plot(cvresult::SlopeCvResult; xvar=:α, index=1; kwargs...)\n\nPlots the cross-validation results from a cross-validated SLOPE model.\n\nArguments\n\ncvresult::SLOPE.SlopeCvResult: The result of a cross-validated SLOPE model, containing multiple cross-validation results for different parameters.\nxvar::Symbol=:α: Variable for the x-axis, options:\n:α: Plot against the regularization parameter alpha (default)\n:step: Plot against the step number in the regularization path\nindex::Int=1: Index of the cross-validation result to plot. If there are multiple values of γ or q, this specifies which set of these to visualize.\n\nKeyword Arguments\n\nkwargs...: Additional arguments passed to the plot, such as:\ntitle: Title for the plot\nlegend: Legend position (default: :none)\nlw: Line width\ncolor: Color scheme\n\nReturns\n\nA plot object showing the cross-validation error, with ribbons for standard error.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, SlopeFit}","page":"API Reference","title":"RecipesBase.apply_recipe","text":"plot(fit::SLOPE.SlopeFit; xvar=:α, response=1, kwargs...)\n\nPlot the coefficient paths from a SLOPE model regularization path.\n\nThis function visualizes how the coefficients change along the regularization path, allowing you to see which variables enter the model and how their effects change as the regularization strength varies.\n\nArguments\n\nfit::SLOPE.SlopeFit: A fitted SLOPE model object containing the regularization path\nxvar::Symbol=:α: Variable for the x-axis, options:\n:α: Plot against the regularization parameter alpha (default)\n:step: Plot against the step number in the regularization path\nresponse::Int=1: For multi-response models, specifies which response's coefficients to plot\nlayout: (DEPRECATED) Layout for multi-class plots, e.g., (rows, cols). Default is (m, 1) for m classes.\n\nKeyword Arguments\n\nkwargs...: Additional arguments passed to the plot, such as:\ntitle: Title for the plot\nlegend: Legend position (default: :none)\nlw: Line width\ncolor: Color scheme\n\nReturns\n\nA plot object showing the coefficient paths\n\n\n\n\n\n","category":"method"},{"location":"#SLOPE","page":"Home","title":"SLOPE","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"You can install the package using the Julia package manager:\n\nusing Pkg\nPkg.add(\"SLOPE\")\n\nAlternatively, you can also install the latest development version of the package from the source code on GitHub by calling\n\nPkg.add(url = \"https://github.com/jolars/SLOPE.jl\")","category":"section"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"SLOPE is a Julia package for Sorted L1 Penalized Estimation (SLOPE), which is a type of regularized regression. SLOPE minimizes the following objective function:\n\nfrac1n sum_i=1^n f(y_i x_i^intercal beta) + alpha sum_j=1^p lambda_j beta_(j)\n\nwhere f(yeta) is the negative log-likelihood contribution of a single observation (y eta). beta_(j) is the j-th coefficient, beta_0 is the intercept, and lambda is a decreasing sequence of regularization weights. x_i is the ith row of the design matrix, and n is the number of observations.\n\nSLOPE is a type of sparse regression, which means that it will, given high enough penalization, set some of the coefficients to zero, effectively removing the corresponding features from the model. If you are familiar with the lasso, then you should know that SLOPE is actually a generalization of the lasso (which you can see by setting all lambda_j to the same value). Unlike the lasso, however, SLOPE also clusters coefficients by settings them to the same magnitude. This helps remove some deficiencies of the lasso in highly correlated settings, and it also allows for selection of more features that is possible with the lasso.","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"First, we'll load the package and fit a simple model:\n\nusing SLOPE\nusing Random\nusing Statistics\n\n# Generate some sample data\nn, p = 100, 20\nRandom.seed!(123)\nX = randn(n, p)\nβ = vcat(fill(3.0, 5), fill(0.0, p-5))  # 5 non-zero coefficients\ny = X * β + 0.5 * randn(n)\n\n# Fit a SLOPE model\nfit = slope(X, y)","category":"section"},{"location":"#Examining-the-Model","page":"Home","title":"Examining the Model","text":"You can examine the results of the fitted model:\n\nfit.coefficients","category":"section"},{"location":"#Cross-Validation","page":"Home","title":"Cross-Validation","text":"To determine the optimal regularization strength, you can use cross-validation:\n\n# Perform cross-validation to find optimal parameters\ncvfit = slopecv(X, y)\n\n# View the optimal α value\ncvfit.best_params","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"The SLOPE.jl package is a thin wrapper around the C++ slope library, which provides all of the core functionality. Therefore, if you find any bugs or have feature requests, then it's likely that you should open a ticket in the slope repository rather than here.\n\nThat being said, if you find any bugs in the Julia wrapper or there are features in the C++ library that are yet to be implemented in the Julia wrapper, then please open an issue in this repository.","category":"section"}]
}
