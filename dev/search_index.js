var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#SLOPE.SLOPE","page":"API Reference","title":"SLOPE.SLOPE","text":"module SLOPE\n\nSorted L-One Penalized Estimation\n\n\n\n\n\n","category":"module"},{"location":"api/#SLOPE.slope","page":"API Reference","title":"SLOPE.slope","text":"slope(x, y; kwargs...) -> NamedTuple\n\nFit a SLOPE (Sorted L1 Penalized Estimation) model to the provided data.\n\nSLOPE is a regularization method that combines the L1 norm with a sorted penalty, encouraging both sparsity and grouping of features.\n\nArguments\n\nx: Matrix of predictors (dense or sparse)\ny: Response variable (vector)\n\nKeyword Arguments\n\nα::Union{AbstractVector,Real,Nothing}=nothing: Alpha sequence for regularization path\nλ::Union{AbstractVector,Nothing}=nothing: Lambda sequence for regularization path\nfit_intercept::Bool=true: Whether to fit an intercept term\nloss::String=\"quadratic\": Type of loss function\ncentering::String=\"mean\": Method for centering predictors\nscaling::String=\"sd\": Method for scaling predictors\npath_length::Int=100: Number of regularization path points\ntol::Float64=1e-5: Convergence tolerance for optimization\nmax_it::Int=10000: Maximum number of iterations\nq::Float64=0.1: Parameter for regularization sequence\nmax_clusters::Union{Int,Nothing}=nothing: Maximum number of clusters (defaults to n+1)\ndev_change_tol::Float64=1e-5: Tolerance for change in deviance\ndev_ratio_tol::Float64=0.999: Tolerance for ratio of deviance\nα_min_ratio::Union{Float64,Nothing}=nothing: Minimum alpha ratio for regularization path\n\nReturns\n\nA NamedTuple containing:\n\nβ: Array of sparse coefficient matrices along the regularization path\nβ0: Array of intercept values along the regularization path\nα: Effective alpha values used\nλ: Effective lambda values used\n\n\n\n\n\n","category":"function"},{"location":"api/#SLOPE.SlopeFit","page":"API Reference","title":"SLOPE.SlopeFit","text":"SlopeFit\n\nA structure containing the results of fitting a SLOPE model.\n\nFields\n\nintercepts::Vector{Vector{Float64}}: A vector of intercept vectors along the regularization path. For each point in the path, contains a vector of length m with class-specific intercepts.\ncoefficients::Vector{SparseMatrixCSC{Float64,Int}}: A vector of sparse coefficient matrices  along the regularization path. Each matrix is of size p×m where p is the number of  predictors and m is the number of response classes (1 for regression).\nα::Vector{Float64}: The alpha values used at each point of the regularization path.\nλ::Vector{Float64}: The lambda values used at each point of the regularization path.\nm::Int: The number of response classes (1 for regression, >1 for multinomial).\nloss::String: The loss function used in the model fitting process.\nclasses::Union{Vector,Nothing}: A vector of unique class labels for the response variable. This is nothing for regression models (continuous responses).\n\n\n\n\n\n","category":"type"},{"location":"api/#SLOPE.slopecv","page":"API Reference","title":"SLOPE.slopecv","text":"slopecv(x, y; α=nothing, λ=nothing, γ=[0.0], q=[0.1], n_folds=10, n_repeats=1, metric=\"mse\", kwargs...)\n\nPerform cross-validation for the SLOPE method to find optimal hyperparameters.\n\nArguments\n\nx::Union{AbstractMatrix,SparseMatrixCSC}: Input feature matrix, can be dense or sparse.\ny::AbstractVector: Target vector.\n\nKeyword Arguments\n\nα::Union{AbstractVector,Real,Nothing}=nothing: SLOPE regularization path. If nothing, it's automatically generated.\nλ::Union{AbstractVector,Nothing}=nothing: Sequence of regularization parameters. If nothing, it's automatically generated.\nγ::Union{AbstractVector,Real}=[0.0]: Parameter controlling the regularization sequence. Multiple values create a grid search.\nq::Union{AbstractVector}=[0.1]: FDR parameter for BH sequence. Multiple values create a grid search.\nn_folds::Int=10: Number of cross-validation folds.\nn_repeats::Int=1: Number of times to repeat the CV process with different fold assignments.\nmetric::String=\"mse\": Evaluation metric for cross-validation. Options include \"mse\", \"mae\", \"accuracy\", etc.\nkwargs...: Additional parameters passed to the SLOPE solver.\n\nReturns\n\nSlopeCvResult: A structure containing:\n\nmetric: The evaluation metric used\nbest_score: The best score achieved during CV\nbest_ind: Index of the best parameter combination\nbest_α_ind: Index of the best alpha value\nbest_params: Dictionary with the best parameter values\nresults: Vector of SlopeGridResult for each parameter combination\n\nExamples\n\n# Basic usage with default parameters\nresult = slopecv(X, y)\n\n# Cross-validation with custom parameters\nresult = slopecv(X, y, γ=[0.0, 0.1, 0.5], q=[0.1, 0.05], n_folds=5, metric=\"accuracy\")\n\n# Access best parameters and score\nbest_q = result.best_params[\"q\"]\nbest_γ = result.best_params[\"γ\"]\nbest_score = result.best_score\n\nSee Also\n\nfit_slope: For fitting a SLOPE model with fixed parameters.\nSlopeParameters: Structure defining parameters for the SLOPE algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/#SLOPE.SlopeGridResult","page":"API Reference","title":"SLOPE.SlopeGridResult","text":"SlopeGridResult\n\nResults for a specific hyperparameter combination in the SLOPE cross-validation grid search.\n\nFields\n\nparams::Dict{String,Any}: Dictionary of hyperparameter values (e.g., \"q\", \"γ\")\nscores::Matrix{Real}: Cross-validation scores for each fold and alpha value\nalphas::Vector{Real}: Sequence of alpha values for the regularization path\nscores_means::Vector{Real}: Mean score across folds for each alpha\nscores_errors::Vector{Real}: Standard errors of scores across folds\n\n\n\n\n\n","category":"type"},{"location":"api/#SLOPE.SlopeCvResult","page":"API Reference","title":"SLOPE.SlopeCvResult","text":"SlopeCvResult\n\nResult structure from SLOPE cross-validation.\n\nFields\n\nmetric::String: The evaluation metric used (e.g., \"mse\", \"accuracy\")\nbest_score::Real: The best score achieved during cross-validation\nbest_ind::Int: Index of the best parameter combination\nbest_α_ind::Int: Index of the best alpha value in the regularization path\nbest_params::Dict{String,Any}: Dictionary with the best parameter values\nresults::Vector{SlopeGridResult}: Grid search results for each parameter combination\n\n\n\n\n\n","category":"type"},{"location":"#SLOPE","page":"Home","title":"SLOPE","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install the package using the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add SLOPE","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, you can also install the latest development version of the package from the source code on GitHub by calling","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url = \"https://github.com/jolars/SLOPE.jl\")","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SLOPE is a Julia package for Sorted L1 Penalized Estimation (SLOPE), which is a type of regularized regression. SLOPE minimizes the following objective function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"frac1n sum_i=1^n f(y_i x_i^intercal beta) + sum_j=1^p lambda_j beta_(j)","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SLOPE.jl package is a thin wrapper around the C++ slope library, which provides all of the core functionality. Therefore, if you find any bugs or have feature requests, then it's likely that you should open a ticket in the slope repository rather than here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"That being said, if you find any bugs in the Julia wrapper or there are features in the C++ library that are yet to be implemented in the Julia wrapper, then please open an issue in this repository.","category":"page"}]
}
